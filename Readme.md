## 1. Принцип единой ответственности (S – Single Responsibility).

В рамках данного проекта каждый класс отвечает за реализацию только определенной задачи.
Так, например, в папках view  и сервис каждый класс отвечает за реализацию задач для 
определенного экземпляра класса: Учитель или Студент.

## 2. Принцип открытости и закрытости (o - Open-Closed).
В проекте реализацию этого принципа можно заметить в папке "data". У нас есть класс "User",
который является корневым классом для создания новых: "Student" и "Teacher". Учитывая, что
разница в классах небольшая, мы не модифицируем корневой класс User, а расширяем его новыми классами,
как раз применяя принцип открытости и закрытости.

## 3. L — Liskov Substitution (Принцип подстановки Барбары Лисков)
Этот принцип был явно продемонстрирован в следующем домашнем задании, где мы хранили в одном списке
и студентов и преподователей и реализовывали итерацию объектов посредством класса User. А так как оба
класса Teacher и Student являются наследниками класса User, никаких конфликтов в итерации не было.

В данном проекте можно рассмотреть этот принцип в реализации классов "UserController" и "TeacherController".
По сути создание объекта класса есть как у родителя, так и у класса потомка, поэтому соблюдается принцип, при котором
класс-потомок способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат.

## 4. I — Interface Segregation (Принцип разделения интерфейсов)
Чтобы показать наглядность этого принципа, я думаю, что стоит обратить внимание на реализацию классов "UserController",
"UserService", "UserView". Они не содержат в себе практически никакого функционала, за исключением основного. А вот классам-наследникам
не приходится затрачивать ресурсы на ненужные процессы. В каждом из класса-потомка реализован только тот функционал, который необходим
для выполнения задачи.

## 5. D — Dependency Inversion (Принцип инверсии зависимостей)
Если я правильно понял этот принцип, то в рамках данного проекта под этот критерий подходят классы, которые включают в себя реализацию
итераций и сравнений: UserComparator, StudentGroupIterator. То есть классы соединяются с интерфейсами Iterator и Comparator, которые по сути
устанавливают связь между классом и инструментом.
